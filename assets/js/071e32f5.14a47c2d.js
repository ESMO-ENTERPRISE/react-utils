"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[390],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=u(n),p=r,c=m["".concat(s,".").concat(p)]||m[p]||h[p]||l;return n?a.createElement(c,i(i({ref:t},d),{},{components:n})):a.createElement(c,i({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7742:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:1},i="Introduction",o={unversionedId:"forms/introduction",id:"forms/introduction",title:"Introduction",description:"A form state manage library, which is simple, easy to use and powerful!",source:"@site/docs/forms/introduction.md",sourceDirName:"forms",slug:"/forms/introduction",permalink:"/react-utils/docs/forms/introduction",draft:!1,editUrl:"https://github.com/ESMO-ENTERPRISE/react-utils/tree/main/docs/forms/introduction.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Forms",permalink:"/react-utils/docs/category/forms"},next:{title:"Form validation",permalink:"/react-utils/docs/forms/validations"}},s={},u=[{value:"Basic Example",id:"basic-example",level:2},{value:"TypeScript Example",id:"typescript-example",level:2},{value:"Other Cool Features",id:"other-cool-features",level:2},{value:"Checkboxes and Radio Buttons",id:"checkboxes-and-radio-buttons",level:2},{value:"More on Fields",id:"more-on-fields",level:2},{value:"The useFormValidation Hook",id:"the-useformvalidation-hook",level:2},{value:"More on Configuration",id:"more-on-configuration",level:2},{value:"Default Error Messages",id:"default-error-messages",level:2},{value:"Setting Multiple Validation Rules",id:"setting-multiple-validation-rules",level:2},{value:"pattern",id:"pattern",level:3},{value:"min and minLength",id:"min-and-minlength",level:3},{value:"max and maxLength",id:"max-and-maxlength",level:3}],d={toc:u},m="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"A form state manage library, which is simple, easy to use and powerful!"),(0,r.kt)("h2",{id:"basic-example"},"Basic Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'const validatorSetup = {\n  firstName: {}, // All fields should have a config object. Name prop of the input is the key.\n  lastName: {\n    required: true, // Add required validation.\n    defaultValue: \'\', // Set a default value. Setting a default value will trigger validation.\n    minLength: 1, // minLength and maxLength should only validate strings\n    maxLength: 100,\n  },\n  age: {\n    pattern: /\\d+/, // Validate with regular expression\n    min: 1, // min and max should only validate numbers\n    max: 100,\n    errorMessages: { // Set custom error messages for each validation.\n      pattern: \'Please enter number for age.\',\n    }\n  },\n};\n\nfunction App() {\n  const {\n    isValid, // Boolean to indicate if the form is valid.\n    values, // Object with all the values of your form, name prop is the key for each corresponding value.\n    handleChange, // Pass this to all onChange props.\n    handleBlur, // Pass this to all onBlur props.\n    setupComplete, // Boolean to indicate when the setup is complete.\n    fields // Object with additional information about fields of your form, name prop is the key for each corresponding field. More on fields later.\n  } = useForm(validatorSetup); // initialize the hook\n\n  return (\n    // Wrap the entire form in a check for setupComplete to avoid the "Input elements should not switch from uncontrolled to controlled (or vice versa)" error.\n    {setupComplete && <form>\n      <input\n        name="firstName"\n        onChange={handleChange}\n        onBlur={handleBlur}\n        value={values.firstName}\n      />\n\n      <input\n        name="lastName"\n        onChange={handleChange}\n        onBlur={handleBlur}\n        value={values.lastName}\n      />\n      // Each field has a boolean showError (in addition to hasError), and an array of error messages\n      {fields.lastName.showError && fields.lastName.errors[0]}\n\n      <input\n        name="age"\n        onChange={handleChange}\n        onBlur={handleBlur}\n        value={values.age}\n      />\n      {fields.age.showError && fields.age.errors[0]}\n\n      // Use isValid for things like disabling the submit button\n      <button type="submit" disabled={!isValid}>Submit</button>\n    </form>}\n  );\n}\n')),(0,r.kt)("h2",{id:"typescript-example"},"TypeScript Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// Define a type with all of the types for your inputs\ntype FormFields = {\n  firstName: string,\n  lastName: string,\n  age: number,\n};\n\n// Add the ValidatorSetup type passing in the FormFields you defined\nconst validatorSetup: ValidatorSetup<FormFields> = {\n  firstName: {\n    // ...other configuration\n  },\n  lastName: {\n    // ...other configuration\n  },\n  age: {\n    // ...other configuration\n  },\n};\n\n// ...everything else the same\n")),(0,r.kt)("h2",{id:"other-cool-features"},"Other Cool Features"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'import React from \'react\';\nconst validatorSetup = {\n  firstName: {\n    // ...other configuration\n  },\n  lastName: {\n    // ...other configuration\n  },\n  age: {\n    // ...other configuration\n  },\n};\n\nfunction App() {\n  const {\n    isValid,\n    values,\n    handleChange,\n    handleBlur,\n    setupComplete,\n    fields,\n    setValues, // Use this to set all/some of your form fields.\n    validate, // Use this to validate all the fields in your form.\n    reset, // Use this to return the form to its original state.\n    } = useForm(validatorSetup);\n\n  const setDefaultValues = () => {\n    setValues({\n      firstName: \'Boaty\',\n      lastName: \'McBoatface\',\n      age: 3,\n    });\n  };\n\n  return (\n    {setupComplete && <form>\n      <input\n        name="firstName"\n        onChange={handleChange}\n        onBlur={handleBlur}\n        value={values.firstName}\n      />\n\n      <input\n        name="lastName"\n        onChange={handleChange}\n        onBlur={handleBlur}\n        value={values.lastName}\n      />\n      {fields.lastName.showError && fields.lastName.errors[0]}\n\n      <input\n        name="age"\n        onChange={handleChange}\n        onBlur={handleBlur}\n        value={values.age}\n      />\n      {fields.age.showError && fields.age.errors[0]}\n\n      <button type="submit" disabled={!isValid}>Submit</button>\n\n      // The validate function will set showError to true for all fields that have any errors.\n      <button type="button" onClick={validate}>Validate</button>\n\n      // The setValues function will set values based on name of the field, and validate each field, setting show error to true on any field with errors.\n      <button type="button" onClick={setDefaultValues}>Set Values</button>\n\n      // The reset function will reset any errors or values, and make the form the same as when it was initially loaded.\n      <button type="button" onClick={reset}>Reset</button>\n    </form>}\n  );\n}\n')),(0,r.kt)("h2",{id:"checkboxes-and-radio-buttons"},"Checkboxes and Radio Buttons"),(0,r.kt)("p",null,"Checkboxes and radio buttons work a little bit differently than text inputs. You need to set the checked property so the UI reflects the values set using setValues and reset functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'const validatorSetup = {\n  checkboxField: {},\n  radioField: {},\n};\n\nfunction App() {\n  const { values, handleChange, handleBlur } = useForm(validatorSetup);\n\n  return (\n    <form>\n      <input\n        type="radio"\n        name="radioField"\n        value="radio"\n        checked={values.radioField === "radio"} // Set checked property like this.\n        onChange={handleChange}\n        onBlur={handleBlur}\n      />\n\n      <input\n        type="checkbox"\n        name="checkboxField"\n        value="checkbox"\n        checked={values.checkboxField === "checkbox"} // Set checked property like this.\n        onChange={handleChange}\n        onBlur={handleBlur}\n      />\n    </form>\n  );\n}\n')),(0,r.kt)("h2",{id:"more-on-fields"},"More on Fields"),(0,r.kt)("p",null,"A field is defined by this type in TypeScript:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type Field = {\n  touched: boolean;\n  dirty: boolean;\n  hasError: boolean;\n  showError: boolean;\n  isRequired: boolean;\n  isValid: boolean;\n  errors: string[];\n};\n")),(0,r.kt)("p",null,"Let's look at each of these properties in more detail."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"touched: Set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," after a field has been blurred once."),(0,r.kt)("li",{parentName:"ul"},"dirty: Set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," after a field receives input (setting a defaultValue or using setValues function also counts)."),(0,r.kt)("li",{parentName:"ul"},"hasError: Set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," if a field has an error. Validations are run immediately during setup, so unless there are no validations, or a valid defaultValue is set, this will be ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," initially."),(0,r.kt)("li",{parentName:"ul"},"showError: Set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," when (in the opinion of this library) you should display error state and error messages. If you don't agree, you can create your own logic for when to show errors using a combination of hasError/touched/dirty."),(0,r.kt)("li",{parentName:"ul"},"isRequired: Set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," if the field has a required validation."),(0,r.kt)("li",{parentName:"ul"},"isValid: Set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," if the field has no errors.")),(0,r.kt)("h2",{id:"the-useformvalidation-hook"},"The useFormValidation Hook"),(0,r.kt)("p",null,"The return value of the hook is defined by this type in TypeScript:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'type UseFormValidator<T> = {\n  fields: {\n    [K in keyof T]: Field;\n  };\n  handleBlur: (\n    event: React.FocusEvent<\n      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n    >\n  ) => void;\n  handleChange: (\n    event: React.ChangeEvent<\n      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\n    >\n  ) => void;\n  isValid: boolean;\n  reset: () => void;\n  setupComplete: boolean;\n  setValues: React.Dispatch<\n    React.SetStateAction<{ [K in keyof T]?: T[K] | undefined } | null>\n  >;\n  validate: () => void;\n  values: {\n    [K in keyof T]: T[K] | "";\n  };\n};\n')),(0,r.kt)("p",null,"Let's look at each of these properties in more detail."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"fields: An object with the name of each field in the form as a key, with an object of type Field (see above) as the value."),(0,r.kt)("li",{parentName:"ul"},"handleBlur: Blur event handler, which sets the ",(0,r.kt)("inlineCode",{parentName:"li"},"touched")," property to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),"."),(0,r.kt)("li",{parentName:"ul"},"handleChange: Change event handler, which updates the values, and runs validations on each field."),(0,r.kt)("li",{parentName:"ul"},"isValid: Boolean set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," when all the fields in the form are valid."),(0,r.kt)("li",{parentName:"ul"},"reset: Returns the form to its original state."),(0,r.kt)("li",{parentName:"ul"},"setupComplete: Boolean to indicate when the setup is complete."),(0,r.kt)("li",{parentName:"ul"},"setValues: Sets all/some of your form fields."),(0,r.kt)("li",{parentName:"ul"},"validate: Validates all the fields in your form."),(0,r.kt)("li",{parentName:"ul"},"values: Object with all the values of your form, name prop is the key for each corresponding value.")),(0,r.kt)("h2",{id:"more-on-configuration"},"More on Configuration"),(0,r.kt)("p",null,"The validator configuration is defined by these types in TypeScript:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'type ValidatorSetup<T> = {\n  [K in keyof T]: Validation<T>;\n};\n\ntype Validation<T> = {\n  defaultValue?: T[keyof T] | "";\n  required?: boolean;\n  pattern?: RegExp;\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  errorMessages?: {\n    required?: string;\n    pattern?: string;\n    min?: string;\n    max?: string;\n    minLength?: string;\n    maxLength?: string;\n  };\n};\n')),(0,r.kt)("p",null,"Let's look at each of these properties in more detail."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"defaultValue: Initial value, if any, that you would like to set the field to have. If there is no defaultValue, it will default to an empty string."),(0,r.kt)("li",{parentName:"ul"},"required: Set to true if the field is required."),(0,r.kt)("li",{parentName:"ul"},"pattern: Regular expression to validate against the value."),(0,r.kt)("li",{parentName:"ul"},"min: A numerical minimum to validate against the value. Value must be a number."),(0,r.kt)("li",{parentName:"ul"},"max: A numerical maximum to validate against the value. Value must be a number."),(0,r.kt)("li",{parentName:"ul"},"minLength: A minimum length of characters validate against the value. Value must be a string."),(0,r.kt)("li",{parentName:"ul"},"maxLength: A maximum length of characters validate against the value. Value must be a string."),(0,r.kt)("li",{parentName:"ul"},"errorMessages: An object, with keys for each type of validation, for setting custom error messages. See default error messages in the next section.")),(0,r.kt)("h2",{id:"default-error-messages"},"Default Error Messages"),(0,r.kt)("p",null,"By default, each validation type have a different default message."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"required: 'This field is required'"),(0,r.kt)("li",{parentName:"ul"},"pattern: 'This field is does not match the correct pattern'"),(0,r.kt)("li",{parentName:"ul"},"min: 'This field does not exceed the min value'"),(0,r.kt)("li",{parentName:"ul"},"max: 'This field exceeds the max value'"),(0,r.kt)("li",{parentName:"ul"},"minLength: 'This field does not exceed the min length'"),(0,r.kt)("li",{parentName:"ul"},"maxLength: 'This field exceeds the max length'")),(0,r.kt)("h2",{id:"setting-multiple-validation-rules"},"Setting Multiple Validation Rules"),(0,r.kt)("p",null,"In most cases, you will only need one validation rule."),(0,r.kt)("h3",{id:"pattern"},"pattern"),(0,r.kt)("p",null,"If you have a pattern rule on a field, you probably don't need required as well (unless your regular expression matches an empty string)."),(0,r.kt)("h3",{id:"min-and-minlength"},"min and minLength"),(0,r.kt)("p",null,"Unless min or minLength is set to 0, you won't need to also set as required as well."),(0,r.kt)("h3",{id:"max-and-maxlength"},"max and maxLength"),(0,r.kt)("p",null,"For max and maxLength, you may want to add required as well, or a min/minLength."))}h.isMDXComponent=!0}}]);