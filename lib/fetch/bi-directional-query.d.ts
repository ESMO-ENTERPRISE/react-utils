import { Maybe } from './utils';
import { SelectDeps } from './subscribe';
import { CreateQueryOptions, QueryState } from './query';
import { StoreKey } from '../store';
export declare const createBiDirectionQuery: <TKey extends StoreKey = StoreKey, TResponse = any, TData extends any[] = any[], TError = unknown, TPageParam = any>(queryFn: (key: TKey, state: QueryState<TKey, TResponse, TData, TError, TPageParam>, direction: 'prev' | 'next') => Promise<TResponse>, options: Omit<CreateQueryOptions<TKey, TResponse, TData, TError, TPageParam>, "select" | "getNextPageParam"> & {
    getPrevPageParam: (lastPage: TResponse, index: number, stateBeforeCallQuery: QueryState<TKey, TResponse, TData, TError, TPageParam>) => Maybe<TPageParam>;
    getNextPageParam: (lastPage: TResponse, index: number, stateBeforeCallQuery: QueryState<TKey, TResponse, TData, TError, TPageParam>) => Maybe<TPageParam>;
    select: (response: TResponse, state: Pick<QueryState<TKey, TResponse, TData, TError, TPageParam>, "data" | "key">, direction: 'prev' | 'next') => TData;
}) => {
    (...args: [Maybe<TKey>, SelectDeps<QueryState<TKey, TResponse, TData, TError, TPageParam>>?] | [SelectDeps<QueryState<TKey, TResponse, TData, TError, TPageParam>>?]): {
        data: (never[] | TData)[number][];
        fetchPrevPage: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        hasPrevPage: boolean;
        isWaitingPrevPage: boolean;
        key: TKey;
        keyHash: string;
        fetch: () => void;
        forceFetch: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        fetchNextPage: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        reset: () => void;
        optimisticUpdate: (response: TResponse | ((prevState: QueryState<TKey, TResponse, TData, TError, TPageParam>) => TResponse)) => {
            revert: () => void;
            invalidate: () => void;
        };
        isWaiting: boolean;
        isWaitingNextPage: boolean;
        isRefetching: boolean;
        isRefetchError: boolean;
        isPreviousData: boolean;
        isOptimisticData: boolean;
        error: TError | undefined;
        errorUpdatedAt: number | undefined;
        retryCount: number;
        isGoingToRetry: boolean;
        pageParam: Maybe<TPageParam>;
        pageParams: Maybe<TPageParam>[];
        hasNextPage: boolean;
        retryNextPageCount: number;
        isGoingToRetryNextPage: boolean;
        status: "loading";
        isLoading: true;
        isSuccess: false;
        isError: false;
        response: undefined;
        responseUpdatedAt: undefined;
    } | {
        data: (never[] | TData)[number][];
        fetchPrevPage: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        hasPrevPage: boolean;
        isWaitingPrevPage: boolean;
        key: TKey;
        keyHash: string;
        fetch: () => void;
        forceFetch: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        fetchNextPage: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        reset: () => void;
        optimisticUpdate: (response: TResponse | ((prevState: QueryState<TKey, TResponse, TData, TError, TPageParam>) => TResponse)) => {
            revert: () => void;
            invalidate: () => void;
        };
        isWaiting: boolean;
        isWaitingNextPage: boolean;
        isRefetching: boolean;
        isRefetchError: boolean;
        isPreviousData: boolean;
        isOptimisticData: boolean;
        error: TError | undefined;
        errorUpdatedAt: number | undefined;
        retryCount: number;
        isGoingToRetry: boolean;
        pageParam: Maybe<TPageParam>;
        pageParams: Maybe<TPageParam>[];
        hasNextPage: boolean;
        retryNextPageCount: number;
        isGoingToRetryNextPage: boolean;
        status: "error";
        isLoading: false;
        isSuccess: false;
        isError: true;
        response: undefined;
        responseUpdatedAt: undefined;
    } | {
        data: (never[] | TData)[number][];
        fetchPrevPage: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        hasPrevPage: boolean;
        isWaitingPrevPage: boolean;
        key: TKey;
        keyHash: string;
        fetch: () => void;
        forceFetch: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        fetchNextPage: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        reset: () => void;
        optimisticUpdate: (response: TResponse | ((prevState: QueryState<TKey, TResponse, TData, TError, TPageParam>) => TResponse)) => {
            revert: () => void;
            invalidate: () => void;
        };
        isWaiting: boolean;
        isWaitingNextPage: boolean;
        isRefetching: boolean;
        isRefetchError: boolean;
        isPreviousData: boolean;
        isOptimisticData: boolean;
        error: TError | undefined;
        errorUpdatedAt: number | undefined;
        retryCount: number;
        isGoingToRetry: boolean;
        pageParam: Maybe<TPageParam>;
        pageParams: Maybe<TPageParam>[];
        hasNextPage: boolean;
        retryNextPageCount: number;
        isGoingToRetryNextPage: boolean;
        status: "success";
        isLoading: false;
        isSuccess: true;
        isError: false;
        response: TResponse;
        responseUpdatedAt: number | undefined;
    };
    get(): {
        prev: QueryState<TKey, TResponse, TData, TError, TPageParam>;
        next: QueryState<TKey, TResponse, TData, TError, TPageParam>;
    };
    setInitialResponse: (options: {
        key?: Maybe<TKey>;
        response: TResponse;
        skipRevalidation?: boolean | undefined;
    }) => void;
    reset(): void;
    resetSpecificKey(key: Maybe<TKey>): void;
    invalidate: () => void;
    invalidateSpecificKey: (key?: Maybe<TKey>) => void;
    suspend: (key?: Maybe<TKey>) => {
        key: TKey;
        keyHash: string;
        fetch: () => void;
        forceFetch: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        fetchNextPage: () => Promise<QueryState<TKey, TResponse, TData, TError, TPageParam>>;
        reset: () => void;
        optimisticUpdate: (response: TResponse | ((prevState: QueryState<TKey, TResponse, TData, TError, TPageParam>) => TResponse)) => {
            revert: () => void;
            invalidate: () => void;
        };
        isWaiting: boolean;
        isWaitingNextPage: boolean;
        isRefetching: boolean;
        isRefetchError: boolean;
        isPreviousData: boolean;
        isOptimisticData: boolean;
        error: TError | undefined;
        errorUpdatedAt: number | undefined;
        retryCount: number;
        isGoingToRetry: boolean;
        pageParam: Maybe<TPageParam>;
        pageParams: Maybe<TPageParam>[];
        hasNextPage: boolean;
        retryNextPageCount: number;
        isGoingToRetryNextPage: boolean;
    } & {
        status: "success";
        isLoading: false;
        isSuccess: true;
        isError: false;
        data: TData;
        response: TResponse;
        responseUpdatedAt: number | undefined;
    };
};
